<!DOCTYPE html>
<html>
    <head>
        <title>TODO supply a title</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script>
            window.onload = function () {
                console.log(Array.prototype.slice)
                var prevChildrenArray = Array.prototype.slice.call(document.getElementsByTagName("li"))
                var iniArray = prevChildrenArray.reverse()
              
                var prevChildren = {}
                prevChildrenArray.forEach(function (el, index) {
                    // el._mountIndex = index
                    prevChildren[el.textContent] = {
                        _mountIndex: index,
                        _name: el.textContent,
                        _currentElement: el
                    }
                })
                function enqueueMove(a, b, c) {
                    console.log(a, b, c)
                    var parent = a._currentElement.parentNode
                    var childNode = nextChildrenArray[b]
                    insertChildAt(parent, childNode, c)
                }
                
                  function insertChildAt(parentNode, childNode, index) {
          // By exploiting arrays returning `undefined` for an undefined index, we can
          // rely exclusively on `insertBefore(node, null)` instead of also using
          // `appendChild(node)`. However, using `undefined` is not allowed by all
          // browsers so we must replace it with `null`.
          parentNode.insertBefore(
            childNode,
            parentNode.childNodes[index] || null
          );
        }
                var avalon = {
                    moveChild: function (child, toIndex, lastIndex) {
                        if (child._mountIndex < lastIndex) {
                            enqueueMove(child._currentElement.parentNode, child._mountIndex, toIndex);
                        }
                    }
                }

   var updateQueue =[]
  function enqueueMove(parentID, fromIndex, toIndex) {
          // NOTE: Null values reduce hidden classes.
          updateQueue.push({
            parentID: parentID,
            parentNode: null,
            type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
            markupIndex: null,
            textContent: null,
            fromIndex: fromIndex,
            toIndex: toIndex
          });
        }
                var nextChildrenArray = prevChildrenArray.slice(0).reverse()

                var nextChildren = {}
                nextChildrenArray.forEach(function (el, index) {
                    //console.log(el.textContent, index)
                    nextChildren[el.textContent] = prevChildren[el.textContent]
                })
                var lastIndex = 0;
                var nextIndex = 0;
                for (var i in nextChildren) {
                    var prevChild = nextChildren[i]
                    avalon.moveChild(prevChild, nextIndex, lastIndex);
                    lastIndex = Math.max(prevChild._mountIndex, lastIndex);
                    prevChild._mountIndex = nextIndex
                    nextIndex++
                    // console.log(i, el._mountIndex)
                }

                console.log(nextChildren)

            }

        </script>
    </head>
    <body>
        <ul>
            <li>aaa</li><li>bbb</li><li>ccc</li><li>ddd</li>
        </ul>
    </body>
</html>
