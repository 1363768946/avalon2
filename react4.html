<!DOCTYPE html>
<html>
    <head>
        <title>TODO supply a title</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script>
            var SEPARATOR = '.';
            var SEPARATOR_LENGTH = SEPARATOR.length;

            var MAX_TREE_DEPTH = 100;

            function getReactRootIDString(index) {
                return SEPARATOR + index.toString(36);
            }

            function isBoundary(id, index) {
                return id.charAt(index) === SEPARATOR || index === id.length;
            }
            function isValidID(id) {
                return id === '' || (
                        id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR
                        );
            }
            function isAncestorIDOf(ancestorID, descendantID) {
                return (
                        descendantID.indexOf(ancestorID) === 0 &&
                        isBoundary(descendantID, ancestorID.length)
                        );
            }
            function getParentID(id) {
                return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
            }
            
          function getNextDescendantID(ancestorID, destinationID) {

          if (ancestorID === destinationID) {
            return ancestorID;
          }
          // Skip over the ancestor and the immediate separator. Traverse until we hit
          // another separator or we reach the end of `destinationID`.
          var start = ancestorID.length + SEPARATOR_LENGTH;
          var i;
          for (i = start; i < destinationID.length; i++) {
            if (isBoundary(destinationID, i)) {
              break;
            }
          }
          return destinationID.substr(0, i);
        }


    function mountComponentIntoNode(
          componentInstance,
          rootID,
          container,
          transaction,
          shouldReuseMarkup) {
          var markup = ReactReconciler.mountComponent(
            componentInstance, rootID, transaction, emptyObject
          );
          componentInstance._isTopLevel = true;
          ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup);
        }

        /**
         * Batched mount.
         *
         * @param {ReactComponent} componentInstance The instance to mount.
         * @param {string} rootID DOM ID of the root node.
         * @param {DOMElement} container DOM element to mount into.
         * @param {boolean} shouldReuseMarkup If true, do not insert markup
         */

        function batchedMountComponentIntoNode(
          componentInstance,
          rootID,
          container,
          shouldReuseMarkup) {
          var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();
          transaction.perform(
            mountComponentIntoNode,
            null,
            componentInstance,
            rootID,
            container,
            transaction,
            shouldReuseMarkup
          );
          ReactUpdates.ReactReconcileTransaction.release(transaction);
        }

        /**
         * Mounting is the process of initializing a React component by creating its
         * representative DOM elements and inserting them into a supplied `container`.
         * Any prior content inside `container` is destroyed in the process.
         *
         *   ReactMount.render(
         *     component,
         *     document.getElementById('container')
         *   );
         *
         *   <div id="container">                   <-- Supplied `container`.
         *     <div data-reactid=".3">              <-- Rendered reactRoot of React
         *       // ...                                 component.
         *     </div>
         *   </div>
         *
         * Inside of `container`, the first element rendered is the "reactRoot".
         */
        var ReactMount = {
          /** Exposed for debugging purposes **/
          _instancesByReactRootID: instancesByReactRootID,

          /**
           * This is a hook provided to support rendering React components while
           * ensuring that the apparent scroll position of its `container` does not
           * change.
           *
           * @param {DOMElement} container The `container` being rendered into.
           * @param {function} renderCallback This must be called once to do the render.
           */
          scrollMonitor: function(container, renderCallback) {
            renderCallback();
          },

          /**
           * Take a component that's already mounted into the DOM and replace its props
           * @param {ReactComponent} prevComponent component instance already in the DOM
           * @param {ReactElement} nextElement component instance to render
           * @param {DOMElement} container container to render into
           * @param {?function} callback function triggered on completion
           */
          _updateRootComponent: function(
            prevComponent,
            nextElement,
            container,
            callback) {
            if ("production" !== "development") {
              ReactElementValidator.checkAndWarnForMutatedProps(nextElement);
            }

            ReactMount.scrollMonitor(container, function() {
              ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);
              if (callback) {
                ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
              }
            });

            if ("production" !== "development") {
              // Record the root element in case it later gets transplanted.
              rootElementsByReactRootID[getReactRootID(container)] =
                getReactRootElementInContainer(container);
            }

            return prevComponent;
          },

          /**
           * Register a component into the instance map and starts scroll value
           * monitoring
           * @param {ReactComponent} nextComponent component instance to render
           * @param {DOMElement} container container to render into
           * @return {string} reactRoot ID prefix
           */
          _registerComponent: function(nextComponent, container) {
            ("production" !== "development" ? invariant(
              container && (
                (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)
              ),
              '_registerComponent(...): Target container is not a DOM element.'
            ) : invariant(container && (
              (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)
            )));

            ReactBrowserEventEmitter.ensureScrollValueMonitoring();

            var reactRootID = ReactMount.registerContainer(container);
            instancesByReactRootID[reactRootID] = nextComponent;
            return reactRootID;
          },

          /**
           * Render a new component into the DOM.
           * @param {ReactElement} nextElement element to render
           * @param {DOMElement} container container to render into
           * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
           * @return {ReactComponent} nextComponent
           */
          _renderNewRootComponent: function(
            nextElement,
            container,
            shouldReuseMarkup
          ) {
            // Various parts of our code (such as ReactCompositeComponent's
            // _renderValidatedComponent) assume that calls to render aren't nested;
            // verify that that's the case.
            ("production" !== "development" ? warning(
              ReactCurrentOwner.current == null,
              '_renderNewRootComponent(): Render methods should be a pure function ' +
              'of props and state; triggering nested component updates from ' +
              'render is not allowed. If necessary, trigger nested updates in ' +
              'componentDidUpdate.'
            ) : null);

            var componentInstance = instantiateReactComponent(nextElement, null);
            var reactRootID = ReactMount._registerComponent(
              componentInstance,
              container
            );

            // The initial render is synchronous but any updates that happen during
            // rendering, in componentWillMount or componentDidMount, will be batched
            // according to the current batching strategy.

            ReactUpdates.batchedUpdates(
              batchedMountComponentIntoNode,
              componentInstance,
              reactRootID,
              container,
              shouldReuseMarkup
            );

            if ("production" !== "development") {
              // Record the root element in case it later gets transplanted.
              rootElementsByReactRootID[reactRootID] =
                getReactRootElementInContainer(container);
            }

            return componentInstance;
          },

          /**
           * Renders a React component into the DOM in the supplied `container`.
           *
           * If the React component was previously rendered into `container`, this will
           * perform an update on it and only mutate the DOM as necessary to reflect the
           * latest React component.
           *
           * @param {ReactElement} nextElement Component element to render.
           * @param {DOMElement} container DOM element to render into.
           * @param {?function} callback function triggered on completion
           * @return {ReactComponent} Component instance rendered in `container`.
           */
          render: function(nextElement, container, callback) {
            ("production" !== "development" ? invariant(
              ReactElement.isValidElement(nextElement),
              'React.render(): Invalid component element.%s', (
                typeof nextElement === 'string' ?
                ' Instead of passing an element string, make sure to instantiate ' +
                'it by passing it to React.createElement.' :
                typeof nextElement === 'function' ?
                ' Instead of passing a component class, make sure to instantiate ' +
                'it by passing it to React.createElement.' :
                // Check if it quacks like an element
                nextElement != null && nextElement.props !== undefined ?
                ' This may be caused by unintentionally loading two independent ' +
                'copies of React.' :
                ''
              )
            ) : invariant(ReactElement.isValidElement(nextElement)));

            var prevComponent = instancesByReactRootID[getReactRootID(container)];

            if (prevComponent) {
              var prevElement = prevComponent._currentElement;
              if (shouldUpdateReactComponent(prevElement, nextElement)) {
                return ReactMount._updateRootComponent(
                  prevComponent,
                  nextElement,
                  container,
                  callback
                ).getPublicInstance();
              } else {
                ReactMount.unmountComponentAtNode(container);
              }
            }

            var reactRootElement = getReactRootElementInContainer(container);
            var containerHasReactMarkup =
              reactRootElement && ReactMount.isRenderedByReact(reactRootElement);

            if ("production" !== "development") {
              if (!containerHasReactMarkup || reactRootElement.nextSibling) {
                var rootElementSibling = reactRootElement;
                while (rootElementSibling) {
                  if (ReactMount.isRenderedByReact(rootElementSibling)) {
                    ("production" !== "development" ? warning(
                      false,
                      'render(): Target node has markup rendered by React, but there ' +
                      'are unrelated nodes as well. This is most commonly caused by ' +
                      'white-space inserted around server-rendered markup.'
                    ) : null);
                    break;
                  }

                  rootElementSibling = rootElementSibling.nextSibling;
                }
              }
            }

            var shouldReuseMarkup = containerHasReactMarkup && !prevComponent;

            var component = ReactMount._renderNewRootComponent(
              nextElement,
              container,
              shouldReuseMarkup
            ).getPublicInstance();
            if (callback) {
              callback.call(component);
            }
            return component;
          },

          /**
           * Constructs a component instance of `constructor` with `initialProps` and
           * renders it into the supplied `container`.
           *
           * @param {function} constructor React component constructor.
           * @param {?object} props Initial props of the component instance.
           * @param {DOMElement} container DOM element to render into.
           * @return {ReactComponent} Component instance rendered in `container`.
           */
          constructAndRenderComponent: function(constructor, props, container) {
            var element = ReactElement.createElement(constructor, props);
            return ReactMount.render(element, container);
          },

          /**
           * Constructs a component instance of `constructor` with `initialProps` and
           * renders it into a container node identified by supplied `id`.
           *
           * @param {function} componentConstructor React component constructor
           * @param {?object} props Initial props of the component instance.
           * @param {string} id ID of the DOM element to render into.
           * @return {ReactComponent} Component instance rendered in the container node.
           */
          constructAndRenderComponentByID: function(constructor, props, id) {
            var domNode = document.getElementById(id);
            ("production" !== "development" ? invariant(
              domNode,
              'Tried to get element with id of "%s" but it is not present on the page.',
              id
            ) : invariant(domNode));
            return ReactMount.constructAndRenderComponent(constructor, props, domNode);
          },

          /**
           * Registers a container node into which React components will be rendered.
           * This also creates the "reactRoot" ID that will be assigned to the element
           * rendered within.
           *
           * @param {DOMElement} container DOM element to register as a container.
           * @return {string} The "reactRoot" ID of elements rendered within.
           */
          registerContainer: function(container) {
            var reactRootID = getReactRootID(container);
            if (reactRootID) {
              // If one exists, make sure it is a valid "reactRoot" ID.
              reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
            }
            if (!reactRootID) {
              // No valid "reactRoot" ID found, create one.
              reactRootID = ReactInstanceHandles.createReactRootID();
            }
            containersByReactRootID[reactRootID] = container;
            return reactRootID;
          },

          /**
           * Unmounts and destroys the React component rendered in the `container`.
           *
           * @param {DOMElement} container DOM element containing a React component.
           * @return {boolean} True if a component was found in and unmounted from
           *                   `container`
           */
          unmountComponentAtNode: function(container) {
            // Various parts of our code (such as ReactCompositeComponent's
            // _renderValidatedComponent) assume that calls to render aren't nested;
            // verify that that's the case. (Strictly speaking, unmounting won't cause a
            // render but we still don't expect to be in a render call here.)
            ("production" !== "development" ? warning(
              ReactCurrentOwner.current == null,
              'unmountComponentAtNode(): Render methods should be a pure function of ' +
              'props and state; triggering nested component updates from render is ' +
              'not allowed. If necessary, trigger nested updates in ' +
              'componentDidUpdate.'
            ) : null);

            ("production" !== "development" ? invariant(
              container && (
                (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)
              ),
              'unmountComponentAtNode(...): Target container is not a DOM element.'
            ) : invariant(container && (
              (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)
            )));

            var reactRootID = getReactRootID(container);
            var component = instancesByReactRootID[reactRootID];
            if (!component) {
              return false;
            }
            ReactMount.unmountComponentFromNode(component, container);
            delete instancesByReactRootID[reactRootID];
            delete containersByReactRootID[reactRootID];
            if ("production" !== "development") {
              delete rootElementsByReactRootID[reactRootID];
            }
            return true;
          },

          /**
           * Unmounts a component and removes it from the DOM.
           *
           * @param {ReactComponent} instance React component instance.
           * @param {DOMElement} container DOM element to unmount from.
           * @final
           * @internal
           * @see {ReactMount.unmountComponentAtNode}
           */
          unmountComponentFromNode: function(instance, container) {
            ReactReconciler.unmountComponent(instance);

            if (container.nodeType === DOC_NODE_TYPE) {
              container = container.documentElement;
            }

            // http://jsperf.com/emptying-a-node
            while (container.lastChild) {
              container.removeChild(container.lastChild);
            }
          },

          /**
           * Finds the container DOM element that contains React component to which the
           * supplied DOM `id` belongs.
           *
           * @param {string} id The ID of an element rendered by a React component.
           * @return {?DOMElement} DOM element that contains the `id`.
           */
          findReactContainerForID: function(id) {
            var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
            var container = containersByReactRootID[reactRootID];

            if ("production" !== "development") {
              var rootElement = rootElementsByReactRootID[reactRootID];
              if (rootElement && rootElement.parentNode !== container) {
                ("production" !== "development" ? invariant(
                  // Call internalGetID here because getID calls isValid which calls
                  // findReactContainerForID (this function).
                  internalGetID(rootElement) === reactRootID,
                  'ReactMount: Root element ID differed from reactRootID.'
                ) : invariant( // Call internalGetID here because getID calls isValid which calls
                  // findReactContainerForID (this function).
                  internalGetID(rootElement) === reactRootID));

                var containerChild = container.firstChild;
                if (containerChild &&
                  reactRootID === internalGetID(containerChild)) {
                  // If the container has a new child with the same ID as the old
                  // root element, then rootElementsByReactRootID[reactRootID] is
                  // just stale and needs to be updated. The case that deserves a
                  // warning is when the container is empty.
                  rootElementsByReactRootID[reactRootID] = containerChild;
                } else {
                  ("production" !== "development" ? warning(
                    false,
                    'ReactMount: Root element has been removed from its original ' +
                    'container. New container:', rootElement.parentNode
                  ) : null);
                }
              }
            }

            return container;
          },

          /**
           * Finds an element rendered by React with the supplied ID.
           *
           * @param {string} id ID of a DOM node in the React component.
           * @return {DOMElement} Root DOM node of the React component.
           */
          findReactNodeByID: function(id) {
            var reactRoot = ReactMount.findReactContainerForID(id);
            return ReactMount.findComponentRoot(reactRoot, id);
          },

          /**
           * True if the supplied `node` is rendered by React.
           *
           * @param {*} node DOM Element to check.
           * @return {boolean} True if the DOM Element appears to be rendered by React.
           * @internal
           */
          isRenderedByReact: function(node) {
            if (node.nodeType !== 1) {
              // Not a DOMElement, therefore not a React component
              return false;
            }
            var id = ReactMount.getID(node);
            return id ? id.charAt(0) === SEPARATOR : false;
          },

          /**
           * Traverses up the ancestors of the supplied node to find a node that is a
           * DOM representation of a React component.
           *
           * @param {*} node
           * @return {?DOMEventTarget}
           * @internal
           */
          getFirstReactDOM: function(node) {
            var current = node;
            while (current && current.parentNode !== current) {
              if (ReactMount.isRenderedByReact(current)) {
                return current;
              }
              current = current.parentNode;
            }
            return null;
          },
        </script>
    </head>
    <body>
        <div>TODO write content</div>
    </body>
</html>
